<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset='UTF-8'>
    <title>MoTa</title>
    <script src='javascripts/data.js'></script>
    <script type='text/javascript'>
        window.onload = function(){

            MoTaGame();
            console.log(map[2][11].downX)

            function MoTaGame(){

                var oYellowKey = document.getElementById("yellowKey");
                var oBlueKey = document.getElementById("blueKey");
                var oRedKey = document.getElementById("redKey");

                var oPlLife = document.getElementById("plLife");
                var oPlAttack = document.getElementById("plAttack");
                var oPlGuard = document.getElementById("plGuard");
                var oPlGold = document.getElementById("plGold");

                var oEnName = document.getElementById("enName");
                var oEnLife = document.getElementById("enLife");
                var oEnAttack = document.getElementById("enAttack");
                var oEnGuard = document.getElementById("enGuard");

                var oMessage = document.getElementById("message");

                var oSaying = document.getElementById("saying");
                var oWords = document.getElementById("words");

                var oBuying = document.getElementById("buying");
                var oBuyingIntro = document.getElementById("buyingIntro");
                var oBuyingMoney = document.getElementById("buyingMoney");

                var oBuyLife = document.getElementById("buyLife");
                var oBuyAttack = document.getElementById("buyAttack");
                var oBuyGuard = document.getElementById("buyGuard");
                var oBuyNone = document.getElementById("buyNone");

                var oLifeNum = document.getElementById("lifeNum");
                var oAttackNum = document.getElementById("attackNum");
                var oGuardNum = document.getElementById("guardNum");

                var oNoMoney = document.getElementById("noMoney");
                var oBuyingNoMoney = document.getElementById("buyingNoMoney");
                var oBuyingContinue = document.getElementById("buying-continue");

                // 在游戏中随时会变的参数
                var player = {
                    x:0,        // 主角的位置X
                    y:0,        // 主角的位置Y
                    dir:0,      // 主角的方向，1左，2上，3右，4下
                    life:0,     // 主角的生命值
                    attack:0,   // 主角的攻击力
                    guard:0,    // 主角的防御力
                    gold:0      // 主角的金币
                }

                // 所有事件触发与否的Flag,0代表未触发，1代表已触发
                var eventFlag = {
                    faceBossAt3F : 0,
                    beatGateKeeperBAt2F : 0,
                    beatGateKeeperAAt2F : 0,
                }

                // 敌方的数据信息，仅在战斗的时候启用
                var enemy = {
                    chsName:"", 
                    life:"",
                    attack:"",
                    guard:""
                }

                var currentFloor;       // 当前楼层
                var dealNum;            // 与奸商商店的已交易次数

                var key = {
                    yellowKey  :0,              // 黄钥匙的数量
                    blueKey    :0,              // 蓝钥匙的数量
                    redKey     :0               // 蓝钥匙的数量
                }


                // 在游戏中理论上不会变的参数
                var doorSpeed = 50;     // 开关门的速度
                var battleSpeed = 200;  // 战斗中一次攻击的速度
                var activeSpeed = 200;  // 活跃的速度


                var openDoorFlag = 0;    // 是否正在开关门和开关墙
                var moveFlag = 1;        // 判断是否可以进行操作，1 代表可以， 0 代表不可以
                var battleFlag = 0;      // 是否刚进行或打算进行一场战斗，1 代表是，0 代表不是。若为 1 ，则应该在下一次移动中刷新数据，并将该变量归0
                var activeFlag = 0;      // 判断敌人和老人动的状态，只有 1 和 0 两种不同的取值

                creatTable();
                init();
                drawFloor();
                gameStart();
                showData()


                function gameStart(){

                    // 这里 键盘事件 设置
                    document.onkeydown = function(event){

                        // 如果 moveFlag 为 0 ，则此时禁止任何操作
                        if(!moveFlag) return false;
                        var e = event || window.event || arguments.callee.caller.arguments[0];
                        if(e && e.keyCode == 37 || e && e.keyCode == 38 || e && e.keyCode == 39 || e && e.keyCode == 40){
                            // 主角的移动事件
                            playerMove(e && e.keyCode);
                        }

                    }

                    // 使敌人和老人动起来的计时器
                    setInterval(function(){
                        if(activeFlag == 1){activeFlag = 0;}
                        else {activeFlag = 1; } 
                        drawFloor();
                    },activeSpeed)

                }

                // 数据初始化
                function init(){

                    // 当前楼层
                    currentFloor = 1;

                    dealNum = 1;

                    player = {
                        x:10,
                        y:5,
                        dir:4,
                        life:10000,
                        attack:25,
                        guard:105,
                        gold:1000 
                    }

                    key = {
                        yellowKey : 10,
                        blueKey   : 10,
                        redKey    : 0
                    }
                }

                // 在主角的移动过程中，必须要先进行判断，再进行移动
                function playerMove(dir){

                    //  如果刚进行或打算进行一场战斗，刷新屏幕数据
                    if(battleFlag){
                        showData();
                        battleFlag = 0;
                    }

                    // 主角应该前往的砖块
                    checkX = player.x;
                    checkY = player.y;

                    switch(dir){
                        case 37:checkY--;player.dir = 1;break;
                        case 38:checkX--;player.dir = 2;break;
                        case 39:checkY++;player.dir = 3;break;
                        case 40:checkX++;player.dir = 4;break;
                    }
                    if(checkMove()){
                        player.x = checkX;
                        player.y = checkY;
                    }

                    drawFloor();

                    // 此处，判断在特定位置发生的事件
                    placeEvent(currentFloor, player.x, player.y);

                    // 判断是否可以移动，并执行若发生移动的事件
                    function checkMove(){
                        if(checkX < 0 || checkX > 10 || checkY < 0 || checkY > 10) return false;
                        switch(map[currentFloor][checkX][checkY].t){
                            case "none":return true;
                            case "wall":{
                                switch(map[currentFloor][checkX][checkY].f){
                                    case "darkNormal":{
                                        openDoorAndWall(currentFloor, checkX, checkY);
                                        return false;
                                    }
                                }
                                break;
                            }
                            case "door":{
                                switch(map[currentFloor][checkX][checkY].f){
                                    case "locked":break;
                                    default:{
                                        // if 判断式里面的式子是钥匙剩余的数量，若大于0则判断为真
                                        // 如果 判断为真 则执行以下操作：开门 钥匙数量-1 改变屏幕上显示的参数
                                        if(key[doorData[map[currentFloor][checkX][checkY].f].require]){
                                            openDoorAndWall(currentFloor, checkX, checkY);
                                            key[doorData[map[currentFloor][checkX][checkY].f].require] -- ;
                                            showData();
                                            break;
                                        }
                                    }
                                }
                                return false;
                            }

                            // 如果是物品，则先根据物品类型加点，再将物品清除，显示加点后的数字，最后使人物移动
                            case "goods":{
                                var time = parseInt(currentFloor/10)+1;
                                switch(map[currentFloor][checkX][checkY].f){
                                    case "yellowKey":key.yellowKey ++ ;break;
                                    case "blueKey":key.blueKey ++ ;break;
                                    case "redKey":key.redKey ++ ;break;
                                    case "redLife":player.life += 50 * time ;break;
                                    case "blueLife":player.life += 200 * time ;break;
                                    case "redGem":player.attack += time ;break;
                                    case "blueGem":player.guard += time ;break;
                                }
                                map[currentFloor][checkX][checkY].t = "none";
                                showData();
                                return true;
                            }

                            case "sword":{
                                player.attack += swordData[map[currentFloor][checkX][checkY].f].attack;
                                map[currentFloor][checkX][checkY].t = "none";
                                showData();
                                return true;
                            }

                            case "shield":{
                                player.guard += shieldData[map[currentFloor][checkX][checkY].f].guard;
                                map[currentFloor][checkX][checkY].t = "none";
                                showData();
                                return true;
                            }

                            case "enemy":{

                                battleFlag = 1;

                                // 将敌方的战斗信息显示到屏幕上
                                enemy.chsName = enemyData[map[currentFloor][checkX][checkY].f].chsName;
                                enemy.life = enemyData[map[currentFloor][checkX][checkY].f].life;
                                enemy.attack = enemyData[map[currentFloor][checkX][checkY].f].attack;
                                enemy.guard = enemyData[map[currentFloor][checkX][checkY].f].guard;

                                showData();

                                // 先行判断敌方防御和己方攻击的关系，若打不动，则返回false
                                if(enemyData[map[currentFloor][checkX][checkY].f].guard >= player.attack) {
                                    showMessage("你打不动他！")
                                    clearEnemyData()
                                    return false;
                                }
                                var tempPlayerLife = player.life;
                                var tempEnemyLife = enemyData[map[currentFloor][checkX][checkY].f].life;

                                // 进行战斗模拟，预估战斗结果
                                while(true){
                                    tempEnemyLife -= player.attack - enemyData[map[currentFloor][checkX][checkY].f].guard;
                                    if(tempEnemyLife < 0)break;
                                    tempPlayerLife -= enemyData[map[currentFloor][checkX][checkY].f].attack - player.guard < 0 ? 0 :enemyData[map[currentFloor][checkX][checkY].f].attack - player.guard;
                                    if(tempPlayerLife < 0)break;
                                }

                                if(tempPlayerLife < 0){
                                    showMessage("你的生命值太低，打不过他！")
                                    clearEnemyData()
                                    return false;
                                }

                                // 若经过判断可以打过，那么。。开打！！
                                while(true){
                                    moveFlag = 0;
                                    setTimeout(attackInBattle,battleSpeed)
                                    return true;
                                }

                                break;
                            }

                            case "stairs":{
                                switch(map[currentFloor][checkX][checkY].f){
                                    case "upStairs":{
                                        currentFloor ++;
                                        checkX = map[currentFloor][11].downX;
                                        checkY = map[currentFloor][11].downY;
                                        player.dir = 4;
                                        drawFloor();
                                        return true;
                                    }
                                    case "downStairs":{
                                        currentFloor --;
                                        checkX = map[currentFloor][11].upX;
                                        checkY = map[currentFloor][11].upY;
                                        player.dir = 4;
                                        drawFloor();
                                        return true;
                                    }
                                }
                            }

                            case "NPC":{
                                var talkName = map[currentFloor][checkX][checkY].f + currentFloor
                                talkWithNPC(talkName,currentFloor,checkX,checkY)
                                return false;
                            }

                            case "bigDealer":{
                                if(map[currentFloor][checkX][checkY].f == "bigDealerM"){
                                    dealWithBigDealer();
                                }
                            }

                        }

                        return false;
                    }

                    // 处理与奸商商店交易的相关事宜
                    // 商店的价钱为 10n(n - 1) + 20 其中n为已交易的次数
                    // 商店可以买的生命量为 n * 100；n = 第几次买
                    // 在这个函数里面，所有的 setTimeout 都是为了避免方向键所带来的对商店操作的误操作！
                    function dealWithBigDealer(){

                        moveFlag = 0;
                        oBuying.style.visibility = "visible"

                        if(player.gold < 10 * dealNum * (dealNum - 1) + 20){

                            oBuyingNoMoney.innerHTML = 10 * dealNum * (dealNum - 1) + 20;

                            oBuyingIntro.style.display = "none";
                            oBuyLife.style.display = "none";
                            oBuyAttack.style.display = "none";
                            oBuyGuard.style.display = "none";
                            oBuyNone.style.display = "none";

                            oNoMoney.style.display = "block";
                            oBuyingContinue.style.display = "block";

                            setTimeout(function(){
                                window.onkeydown = function(){
                                    endDeal();
                                }
                            },300);
                        }
                        else{

                            oBuyingIntro.style.display = "block";
                            oBuyLife.style.display = "block";
                            oBuyAttack.style.display = "block";
                            oBuyGuard.style.display = "block";
                            oBuyNone.style.display = "block";

                            oBuyingContinue.style.display = "none";
                            oNoMoney.style.display = "none";

                            var time = parseInt(currentFloor/10)+1;

                            oBuyingMoney.innerHTML = 10 * dealNum * (dealNum - 1) + 20;
                            oLifeNum.innerHTML = 100 * dealNum;
                            oAttackNum.innerHTML = 2 * time;
                            oGuardNum.innerHTML = 4 * time;

                            setTimeout(function(){
                                window.onkeydown = function(){
                                    var e = event || window.event || arguments.callee.caller.arguments[0];
                                    switch(e && e.keyCode){
                                        case 49: case 97: oBuyLife.style.backgroundColor = "#14d855";break;
                                        case 50: case 98: oBuyAttack.style.backgroundColor = "#14d855";break;
                                        case 51: case 99: oBuyGuard.style.backgroundColor = "#14d855";break;
                                        default: oBuyNone.style.backgroundColor = "#14d855";
                                    }
                                }
                            },300);

                            setTimeout(function(){
                                window.onkeyup = function(){
                                    var e = event || window.event || arguments.callee.caller.arguments[0];
                                    switch(e && e.keyCode){
                                        case 49: case 97: player.life += parseInt(oLifeNum.innerHTML);player.gold -= parseInt(oBuyingMoney.innerHTML);dealNum++;break;
                                        case 50: case 98: player.attack += parseInt(oAttackNum.innerHTML);player.gold -= parseInt(oBuyingMoney.innerHTML);dealNum++;break;
                                        case 51: case 99: player.guard += parseInt(oGuardNum.innerHTML);player.gold -= parseInt(oBuyingMoney.innerHTML);dealNum++;break;
                                    }
                                    endDeal();
                                }
                            },300)


                            oBuyLife.onclick = function(){player.life += parseInt(oLifeNum.innerHTML);player.gold -= parseInt(oBuyingMoney.innerHTML);dealNum++;endDeal();}
                            oBuyAttack.onclick = function(){player.attack += parseInt(oAttackNum.innerHTML);player.gold -= parseInt(oBuyingMoney.innerHTML);dealNum++;endDeal();}
                            oBuyGuard.onclick = function(){player.guard += parseInt(oGuardNum.innerHTML);player.gold -= parseInt(oBuyingMoney.innerHTML);dealNum++;endDeal();}
                            oBuyNone.onclick = function(){endDeal();}
                        }

                        
                        // 结束交易需要进行的相关操作
                        function endDeal(){
                            oBuyLife.style.backgroundColor = "";
                            oBuyAttack.style.backgroundColor = "";
                            oBuyGuard.style.backgroundColor = "";
                            oBuyNone.style.backgroundColor = "";

                            showData();
                            oBuying.style.visibility = "hidden"
                            moveFlag = 1;
                            window.onkeydown = null;
                            window.onkeyup = null;
                        }

                    }


                    // 战斗中一次攻击的函数
                    // 其中，敌人先受到攻击，如果体力小于0，就将体力归0，并显示数据，再清除数据，在改变并重绘地图；如果体力值不为 0 ，则主角受到攻击，显示数据，并进行下一场战斗的计时
                    function attackInBattle(){
                        enemy.life -= player.attack - enemyData[map[currentFloor][checkX][checkY].f].guard;
                        if(enemy.life < 0){
                            enemy.life = 0;
                            player.gold += enemyData[map[currentFloor][checkX][checkY].f].gold;

                            showData();
                            clearEnemyData();

                            map[currentFloor][checkX][checkY].t = "none";
                            drawFloor();

                            // 检查杀死敌人的事件
                            enemyEvent(currentFloor);

                            moveFlag = 1;
                        }
                        else{
                            player.life -= enemyData[map[currentFloor][checkX][checkY].f].attack - player.guard < 0 ? 0 :enemyData[map[currentFloor][checkX][checkY].f].attack - player.guard;
                            showData();
                            setTimeout(attackInBattle,battleSpeed);
                        }
                    }

                    // 清除敌人数据
                    function clearEnemyData(){
                        enemy.chsName = "";
                        enemy.life = "";
                        enemy.attack = "";
                        enemy.guard = "";
                    }
                }



                // 重绘当前楼层
                function drawFloor(){
                    // console.log(enemyData[map[currentFloor][2][1].f].src);

                    // 绘制地图上 除主角以外 的基本信息
                    for(var i = 0; i < 11; i++){
                        for(var j = 0; j < 11; j++){
                            // console.log(currentFloor + '-' + i + '-' + j)
                            switch(map[currentFloor][i][j].t){
                                case "none" : {
                                    var newBk = "";
                                    addBkImage(i,j,newBk,0,0);
                                    break;
                                }
                                case "enemy": {
                                    // console.log(i+'-'+j);
                                    var newBk = "images/Characters/" +  enemyData[map[currentFloor][i][j].f].src;
                                    var offY = enemyData[map[currentFloor][i][j].f].offsetY;
                                    addBkImage(i,j,newBk,activeFlag * -32,offY);
                                    break;
                                }
                                case "wall": {
                                    if(openDoorFlag)break;
                                    var newBk = "images/Characters/" +  wallData[map[currentFloor][i][j].f].src;
                                    var offX = wallData[map[currentFloor][i][j].f].offsetX;
                                    addBkImage(i,j,newBk,offX,0);
                                    break;
                                }
                                case "door": {
                                    if(openDoorFlag)break;
                                    var newBk = "images/Characters/" +  doorData[map[currentFloor][i][j].f].src;
                                    var offX = doorData[map[currentFloor][i][j].f].offsetX;
                                    addBkImage(i,j,newBk,offX,0);
                                    break;
                                }
                                case "goods":{
                                    var newBk = "images/Characters/" +  goodsData[map[currentFloor][i][j].f].src;
                                    var offX = goodsData[map[currentFloor][i][j].f].offsetX;
                                    addBkImage(i,j,newBk,offX,0);
                                    break;
                                }
                                case "stairs":{
                                    var newBk = "images/" + stairsData[map[currentFloor][i][j].f].src;
                                    addBkImage(i,j,newBk,0,0);
                                    break;
                                }
                                case "NPC":{
                                    var newBk = "images/Characters/" + NPCData[map[currentFloor][i][j].f].src;
                                    var offY = NPCData[map[currentFloor][i][j].f].offsetY;
                                    addBkImage(i,j,newBk,activeFlag * -64,offY);
                                    break;
                                }
                                case "bigDealer":{
                                    var newBk = "images/Characters/" +  bigDealerData[map[currentFloor][i][j].f].src;
                                    var offX = bigDealerData[map[currentFloor][i][j].f].offsetX;
                                    addBkImage(i,j,newBk,offX,0);
                                    break;
                                }
                                case "sword":{
                                    var newBk = "images/Characters/" +  swordData[map[currentFloor][i][j].f].src;
                                    var offX = swordData[map[currentFloor][i][j].f].offsetX;
                                    var offY = swordData[map[currentFloor][i][j].f].offsetY;
                                    addBkImage(i,j,newBk,offX,offY);
                                    break;
                                }
                                case "shield":{
                                    var newBk = "images/Characters/" +  shieldData[map[currentFloor][i][j].f].src;
                                    var offX = shieldData[map[currentFloor][i][j].f].offsetX;
                                    var offY = shieldData[map[currentFloor][i][j].f].offsetY;
                                    addBkImage(i,j,newBk,offX,offY);
                                    break;
                                }
                            }
                        }
                    }

                    // 绘制主角
                    var playerOffY;
                    switch(player.dir){
                        case 1: playerOffY = -33;break;
                        case 2: playerOffY = -99;break;
                        case 3: playerOffY = -66;break;
                        case 4: playerOffY = 0;break;
                    }
                    // console.log(player.x+'-'+player.y);
                    var oToChange = document.getElementById(player.x+'-'+player.y);
                    oToChange.style.background = "url('images/Characters/Actor01-Braver01.png') 0px "+ playerOffY + "px no-repeat," + oToChange.style.background;


                    function addBkImage(i, j, bkImage, offX, offY){
                        var oToChange = document.getElementById(i+'-'+j);
                        oToChange.style.background = "url('" + newBk + "') " + offX + "px " + offY + "px no-repeat,url('images/Characters/Other09.png') 0px 0 no-repeat";
                    }

                }

                // 刷新屏幕上显示的基本数据
                function showData(){
                    oYellowKey.innerHTML = key.yellowKey;
                    oBlueKey.innerHTML = key.blueKey;
                    oRedKey.innerHTML = key.redKey;

                    oPlLife.innerHTML = player.life;
                    oPlAttack.innerHTML = player.attack;
                    oPlGuard.innerHTML = player.guard;
                    oPlGold.innerHTML = player.gold;

                    oEnName.innerHTML = enemy.chsName;
                    oEnLife.innerHTML = enemy.life;
                    oEnAttack.innerHTML = enemy.attack;
                    oEnGuard.innerHTML = enemy.guard;
                }

                // 芝麻开门、芝麻开墙 此函数 提供动画效果 和 动画结束后 将门或墙至零的效果
                function openDoorAndWall(currentFloor, i, j){

                    moveFlag = 0;
                    openDoorFlag = 1;

                    var oToChange = document.getElementById(i+'-'+j);
                    var pre = oToChange.style.background.match(/^url.*?px/)// url("images/Characters/Event01-Wall01.png") -32px
                    var after = oToChange.style.background.match(/ url.*?repeat$/) //  url("images/Characters/Other09.png") 0px 0px no-repeat

                    setTimeout(function(){
                        oToChange.style.background = pre[0] + " -32px no-repeat," + after[0];
                        setTimeout(function(){
                            oToChange.style.background = pre[0] + " -64px no-repeat," + after[0];
                            setTimeout(function(){
                                oToChange.style.background = pre[0] + " -96px no-repeat," + after[0];
                                setTimeout(function(){
                                    map[currentFloor][i][j].t = "none";
                                    oToChange.style.background = after[0];
                                    moveFlag = 1;
                                    openDoorFlag = 0;
                                }, doorSpeed)
                            }, doorSpeed)
                        }, doorSpeed)
                    }, doorSpeed)
                }


                // 输出调试信息
                function showMessage(msg){
                    var dateTime = new Date();
                    oMessage.innerHTML = (dateTime.toLocaleString() + " " + msg + "<br>"); 
                }

                // 处理与 NPC 对话的相关事宜
                // 返回 true 则代表老人可以去死了，返回 false 则代表老人还需要活下来
                // 如果有什么其他事情，在此函数里面一并处理
                // 对里面的 wordsNum 的一点说明：由于在与老人交谈时，方向键本身就已经是 window.keydown 了
                // 所以将其初始设置成 -1，以便可以正常对话
                // 传入的参数可以是1个也可以是4个，若是1个，则为所要调取的对话数据的名称。若是4个，则还有当前楼层，横纵坐标，
                // 一般来说，事件对话传1个参数，主动对话传4个参数
                function talkWithNPC(talkName,curFloor,i,j){

                    moveFlag = 0;
                    wordsNum = -1;
                    oSaying.style.visibility = "visible"

                    // 因为要同时设置两个键盘事件，为使他们互不冲突，此处将对话的键盘事件设定在 window 上
                    window.onkeydown = function(){
                        wordsNum ++;

                        // 如果对话结束，则结束对话，并关闭对话框
                        if(wordsNum == sayingData[talkName].words.length){
                            moveFlag = 1;
                            oSaying.style.visibility = "hidden";
                            window.onkeydown = null;

                            if(!(typeof(curFloor) == 'undefined')){
                                map[curFloor][i][j].t = "none";
                                drawFloor();
                            }
                            if(typeof sayingData[talkName].event != 'undefined'){
                                eval(sayingData[talkName].event);
                            }
                        }
                        // 如果对话没有结束，则显示接下来的对话
                        else {
                            oWords.innerHTML = sayingData[talkName].words[wordsNum];
                        }

                    }
                }

                // 到达某地点时会发生的事情
                function placeEvent(curFloor, i, j){
                    switch(curFloor){
                        // 3层 首次遭遇魔王！
                        case 3:{
                            if(i == 8 && j == 4 && !eventFlag.faceBossAt3F){
                                eventFlag.faceBossAt3F = 1;
                                talkWithNPC("faceBossAt3F");
                            }
                        }
                    }
                }

                // 击败某怪物时发生的事情
                function enemyEvent(curFloor){
                    switch(curFloor){
                        // 2层 击退中级卫兵
                        case 2:{
                            if(map[2][1][5].t == 'none' && map[2][1][7].t == 'none' && !eventFlag.beatGateKeeperBAt2F){
                                eventFlag.beatGateKeeperBAt2F = 1;
                                openDoorAndWall(2,4,4);
                                openDoorAndWall(2,7,4);
                                openDoorAndWall(2,10,4);
                                openDoorAndWall(2,4,8);
                                openDoorAndWall(2,7,8);
                                openDoorAndWall(2,10,8);
                            }
                            break;
                        }
                        // 8层 击退初级卫兵
                        case 8:{
                            if(map[8][4][8].t == 'none' && map[8][4][10].t == 'none' && !eventFlag.beatGateKeeperAAt9F){
                                eventFlag.beatGateKeeperAAt9F = 1;
                                openDoorAndWall(8,3,9);
                            }
                            break;
                        }
                    }
                }

                // 绘制初始表格
                function creatTable(){
                    // '+i+'-'+j+'
                    var oGameTable = document.getElementById("gameTable");
                    var table = '<table><tbody>';
                    for(var i = 0; i < 11; i++){
                        table += '<tr>';
                        for(var j = 0; j < 11; j++){
                            table += '<td id="' + i + '-' + j +'"></td>';
                        }
                        table += '</tr>';
                    }
                    table += '</tbody></table>';
                    oGameTable.innerHTML += table;
                }
            };


        }



        
    </script>
</head>
<style type="text/css">
    *{margin: 0;padding: 0;}
    table{border-collapse:collapse;margin: 0 auto 0 auto;border: 5px solid rgb(119,68,34);float: right;}
    td{width: 32px;height:32px;font-size: 10px;text-align: center;
        /*background: url("images/Characters/Event01-Wall02.png") -64px 0 no-repeat;*/
        }

    #saying,#buying{
        width: 270px;
        height: 170px;
        background-color: #38a2ec;
        opacity: 0.8;
        position: absolute;
        top:90px;
        padding: 20px;
        margin:0 auto;

        font-family: 微软雅黑;
        font-size: 14px;

        visibility: hidden;
    }


    #noMoney{
        text-indent: 1em;
        font-size: 24px;
        line-height: 45px;
    }

    #buyingNoMoney{
        color: green;
        font-size: 30px;
    }

    #buyingMoney{
        color: green;
        font-size: 20px;
    }

    .buyingList{
        width: 230px;
        margin:8px 0 5px 17px;
        padding: 3px;
        background-color: #1487d8;
        cursor: pointer;
    }

    .buyingList:hover{
        background-color: #14d855;
    }

    #words,#buyingIntro{
        text-indent:2em;
    }

    #saying-continue,#buying-continue{
        position: absolute;
        bottom: 12px;
        right: 20px;
    }

    #gameDiv{
        height: 360px;
        width: 600px;
        border: 2px solid red;
        margin: 0 auto;
    }

    #baseMessage{
        height: 360px;
        width: 200px;
        float: left
    }

    #gameTable{
        height: 360px;
        width: 358px;
        float: left;
    }
</style>
<body>
    <div id='gameDiv'>
        <div id="baseMessage">
            <p>黄钥匙:<span id="yellowKey"></span></p>
            <p>蓝钥匙:<span id="blueKey"></span></p>
            <p>红钥匙:<span id="redKey"></span></p>
            <p>体力值:<span id="plLife"></span></p>
            <p>攻击:<span id="plAttack"></span></p>
            <p>防御:<span id="plGuard"></span></p>
            <p>金币:<span id="plGold"></span></p>
            <br>
            <p>敌名称:<span id="enName"></span></p>
            <p>敌体力值:<span id="enLife"></span></p>
            <p>敌攻击:<span id="enAttack"></span></p>
            <p>敌防御:<span id="enGuard"></span></p>
            <br>
            <p>信息栏：<span id="message"></span></p>
        </div>
        <div id="gameTable">
            
        </div>

        <div id="saying">
            <p id="words">孩子，继续努力啊！孩子，继续努力啊！孩子，继续努力啊！孩子，继续努力啊！孩子，继续努力啊！孩子，继续努力啊！</p>
            <p id="saying-continue">请按任意键继续</p>
        </div>

        <div id="buying">
            <p id="buyingIntro">欢迎来到奸商商店！！你只需要 <span id = "buyingMoney">20</span> 金币就可以买到称心如意的商品！</p>
            <p class="buyingList" id="buyLife">1、购买 <span id="lifeNum">400</span> 点体力值</p>
            <p class="buyingList" id="buyAttack">2、购买 <span id="attackNum">2</span> 点攻击</p>
            <p class="buyingList" id="buyGuard">3、购买 <span id="guardNum">4</span> 点防御</p>
            <p class="buyingList" id="buyNone">4、嗯。。我再考虑考虑</p>
            <p id="noMoney">你的金币不足 <span id = "buyingNoMoney">20</span> 枚。你别想从我这里获得任何东西！</p>
            <p id="buying-continue">请按任意键继续</p>
        </div>
    </div>
</body>
</html>